const fs = require('fs');
const path = require('path');
const SpotifyAuth = require('../scrapper/authentication');
const SpotifyPlaylists = require('../scrapper/playlists');

class PlaylistManager {
    constructor(clientId, clientSecret) {
        this.auth = new SpotifyAuth(clientId, clientSecret);
        this.playlistsApi = new SpotifyPlaylists(this.auth);
        this.metadataFile = 'data/playlists.json';
    }

    /**
     * Initialiser l'authentification
     */
    async initialize() {
        console.log('üöÄ Initialisation...');
        
        // Essayer de charger un √©tat d'authentification existant
        const authLoaded = this.auth.loadAuthState();
        
        if (authLoaded && this.auth.isTokenValid()) {
            console.log('‚úÖ Authentification existante valide');
        } else {
            console.log('üîê Authentification requise...');
            await this.auth.authenticate();
            this.auth.saveAuthState();
        }
    }

    /**
     * FONCTION BUSINESS 1: Synchroniser les playlists
     * R√©cup√®re toutes les playlists et les sauvegarde avec payload minimal
     */
    async syncPlaylists() {
        await this.initialize();
        
        console.log('üìã Synchronisation des playlists...');
        
        // R√©cup√©rer toutes les playlists depuis l'API
        const apiPlaylists = await this.playlistsApi.getAllPlaylists();
        
        // Charger les m√©tadonn√©es existantes
        const existingMetadata = this.loadExistingMetadata();
        const existingMap = new Map(existingMetadata.map(p => [p.id, p]));
        
        console.log(`üìä Existantes: ${existingMetadata.length}, D√©couvertes: ${apiPlaylists.length}`);

        // Cr√©er les m√©tadonn√©es synchronis√©es avec payload minimale
        const syncedMetadata = apiPlaylists.map(playlist => {
            const existing = existingMap.get(playlist.id);
            
            return {
                id: playlist.id,
                name: playlist.name,
                tracks_total: playlist.tracks.total,
                // Garder les flags existants ou mettre false par d√©faut
                to_extract: existing?.to_extract || false
            };
        });

        // Compter les nouvelles playlists
        const newCount = syncedMetadata.filter(p => !existingMap.has(p.id)).length;
        if (newCount > 0) {
            console.log(`‚ú® ${newCount} nouvelles playlists d√©couvertes`);
        }

        // Sauvegarder les m√©tadonn√©es synchronis√©es
        this.saveMetadata(syncedMetadata);
        
        console.log(`‚úÖ Synchronisation termin√©e - ${syncedMetadata.length} playlists`);
        return syncedMetadata;
    }

    /**
     * FONCTION BUSINESS 2: Extraire les playlists marqu√©es
     * Extrait toutes les playlists avec to_extract: true et cr√©e des CSV timestamp√©s
     */
    async extractMarkedPlaylists() {
        await this.initialize();
        
        console.log('üéØ Extraction des playlists marqu√©es...');
        
        // Charger les m√©tadonn√©es
        const metadata = this.loadExistingMetadata();
        const toExtract = metadata.filter(p => p.to_extract);
        
        if (toExtract.length === 0) {
            console.log('‚ÑπÔ∏è Aucune playlist marqu√©e pour extraction');
            console.log('üí° Modifiez le fichier data/playlists.json pour marquer des playlists (to_extract: true)');
            return [];
        }

        return await this.extractPlaylists(toExtract);
    }

    /**
     * FONCTION BUSINESS 3: Lister les playlists avec statut
     * Affiche toutes les playlists avec leur statut d'extraction
     */
    listPlaylists() {
        const metadata = this.loadExistingMetadata();
        
        if (metadata.length === 0) {
            console.log('üìã Aucune playlist trouv√©e. Ex√©cutez syncPlaylists() d\'abord.');
            return [];
        }
        
        console.log(`\nüìã Vos playlists (${metadata.length} total):`);
        console.log('='.repeat(60));
        
        const toExtract = metadata.filter(p => p.to_extract);
        console.log(`üéØ √Ä extraire: ${toExtract.length}`);
        console.log('');

        metadata.forEach((playlist, index) => {
            const status = playlist.to_extract ? 'üéØ' : '‚ö™';
            console.log(`${status} ${(index + 1).toString().padStart(3)}. ${playlist.name} (${playlist.tracks_total} musiques)`);
        });

        console.log('\nüí° Pour marquer/d√©marquer des playlists, modifiez "to_extract" dans data/playlists.json');
        return metadata;
    }

    /**
     * FONCTION BUSINESS 4: Extraire des playlists sp√©cifiques
     * Permet de r√©-extraire certaines playlists par nom (partiel)
     * @param {Array<string>} playlistNames - Noms (partiels) des playlists √† extraire
     */
    async extractSpecificPlaylists(playlistNames) {
        await this.initialize();
        
        console.log('üéØ Extraction de playlists sp√©cifiques...');
        
        // Charger les m√©tadonn√©es
        const metadata = this.loadExistingMetadata();
        const toExtract = metadata.filter(playlist => 
            playlistNames.some(name => 
                playlist.name.toLowerCase().includes(name.toLowerCase())
            )
        );
        
        if (toExtract.length === 0) {
            console.log('‚ùå Aucune playlist trouv√©e avec ces noms:');
            playlistNames.forEach(name => console.log(`  - "${name}"`));
            console.log('\nüìã Playlists disponibles:');
            metadata.forEach(p => console.log(`  - ${p.name}`));
            return [];
        }

        console.log(`üéµ ${toExtract.length} playlists trouv√©es:`);
        toExtract.forEach(p => console.log(`  - ${p.name} (${p.tracks_total} musiques)`));

        return await this.extractPlaylists(toExtract);
    }

    /**
     * FONCTION BUSINESS 4: Extraire une playlist par ID
     * M√©thode simple : passer l'ID et √ßa extrait
     * @param {string} playlistId - ID de la playlist √† extraire
     */
    async extractPlaylistById(playlistId) {
        await this.initialize();
        
        console.log(`üéØ Extraction de la playlist ID: ${playlistId}`);
        
        // Charger les m√©tadonn√©es pour r√©cup√©rer le nom
        const metadata = this.loadExistingMetadata();
        const playlist = metadata.find(p => p.id === playlistId);
        
        if (!playlist) {
            console.log(`‚ùå Playlist avec ID "${playlistId}" non trouv√©e`);
            console.log('üí° Ex√©cutez listPlaylists() pour voir les IDs disponibles');
            return null;
        }

        console.log(`üéµ Extraction de "${playlist.name}"...`);

        try {
            // R√©cup√©rer les tracks via l'API
            const tracks = await this.playlistsApi.getPlaylistTracks(playlistId, playlist.name);
            
            // Cr√©er le timestamp et nom de fichier
            const timestamp = this.generateTimestamp();
            const safePlaylistName = this.sanitizeFilename(playlist.name);
            const filename = `${timestamp}_${safePlaylistName}.csv`;
            
            // Cr√©er le dossier de destination
            const outputDir = 'data/extractions';
            if (!fs.existsSync(outputDir)) {
                fs.mkdirSync(outputDir, { recursive: true });
            }
            
            const filepath = path.join(outputDir, filename);
            
            // Sauvegarder en CSV
            this.saveTracksToCSV(tracks, playlist, filepath);
            
            console.log(`‚úÖ "${playlist.name}": ${tracks.length} musiques ‚Üí ${filename}`);
            
            return {
                playlist: playlist.name,
                filename: filename,
                tracks_count: tracks.length,
                filepath: filepath
            };
            
        } catch (error) {
            console.error(`‚ùå Erreur pour "${playlist.name}": ${error.message}`);
            return null;
        }
    }

    // =====================================
    // FONCTIONS UTILITAIRES INTERNES
    // =====================================

    /**
     * Extraire une liste de playlists (utilis√© par extractMarkedPlaylists et extractSpecificPlaylists)
     */
    async extractPlaylists(playlistsToExtract) {
        // Cr√©er le timestamp
        const timestamp = this.generateTimestamp();
        
        // Cr√©er le dossier de destination
        const outputDir = 'data/extractions';
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        const extractedFiles = [];

        // Extraire chaque playlist
        for (const playlistMeta of playlistsToExtract) {
            try {
                console.log(`\nüéµ Extraction de "${playlistMeta.name}"...`);
                
                // R√©cup√©rer les tracks via l'API
                const tracks = await this.playlistsApi.getPlaylistTracks(playlistMeta.id, playlistMeta.name);
                
                // Cr√©er le nom de fichier
                const safePlaylistName = this.sanitizeFilename(playlistMeta.name);
                const filename = `${timestamp}_${safePlaylistName}.csv`;
                const filepath = path.join(outputDir, filename);
                
                // Sauvegarder en CSV avec formatage corrig√©
                this.saveTracksToCSV(tracks, playlistMeta, filepath);
                
                extractedFiles.push({
                    playlist: playlistMeta.name,
                    filename: filename,
                    tracks_count: tracks.length
                });
                
                console.log(`‚úÖ "${playlistMeta.name}": ${tracks.length} musiques ‚Üí ${filename}`);
                
            } catch (error) {
                console.error(`‚ùå Erreur pour "${playlistMeta.name}": ${error.message}`);
            }
        }

        console.log(`\nüéâ Extraction termin√©e - ${extractedFiles.length} fichiers cr√©√©s dans ${outputDir}/`);
        return extractedFiles;
    }

    /**
     * Charger les m√©tadonn√©es existantes
     */
    loadExistingMetadata() {
        try {
            if (fs.existsSync(this.metadataFile)) {
                const content = fs.readFileSync(this.metadataFile, 'utf8');
                return JSON.parse(content);
            }
        } catch (error) {
            console.log('‚ö†Ô∏è Erreur lors du chargement des m√©tadonn√©es:', error.message);
        }
        return [];
    }

    /**
     * Sauvegarder les m√©tadonn√©es
     */
    saveMetadata(metadata) {
        // Cr√©er le dossier si n√©cessaire
        const dir = path.dirname(this.metadataFile);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(this.metadataFile, JSON.stringify(metadata, null, 2));
        console.log(`üíæ M√©tadonn√©es sauvegard√©es dans ${this.metadataFile}`);
    }

    /**
     * Sauvegarder les tracks en CSV (version simple avec point-virgule)
     */
    saveTracksToCSV(tracks, playlistInfo, filepath) {
        // En-t√™tes CSV simples
        const headers = [
            'Position',
            'Titre',
            'Artistes',
            'Album',
            'Date_sortie',
            'Duree',
            'Popularite',
            'Explicite',
            'URL_Spotify',
            'ID_Spotify'
        ];

        // Fonction pour nettoyer simplement (enlever point-virgule pour √©viter confusion)
        const cleanField = (field) => {
            if (field === null || field === undefined) {
                return '';
            }
            
            let stringField = String(field);
            
            // Nettoyer : enlever les point-virgules et caract√®res probl√©matiques
            stringField = stringField.replace(/[;"\n\r]/g, ' ');
            
            // Nettoyer les caract√®res sp√©ciaux mais garder plus de choses
            stringField = stringField.replace(/[^\w\s\-\.\:\/]/g, '');
            
            // Supprimer les espaces multiples
            stringField = stringField.replace(/\s+/g, ' ').trim();
            
            return stringField;
        };

        // Cr√©er les lignes CSV avec point-virgule
        const csvLines = [];
        
        // Ligne d'en-t√™tes
        csvLines.push(headers.join(';'));
        
        // Lignes de donn√©es nettoy√©es
        tracks.forEach(track => {
            const row = [
                cleanField(track.position),
                cleanField(track.name),
                cleanField(track.artists),
                cleanField(track.album),
                cleanField(track.release_date),
                cleanField(track.duration_formatted),
                cleanField(track.popularity),
                cleanField(track.explicit ? 'Oui' : 'Non'),
                cleanField(track.external_urls),
                cleanField(track.spotify_id)
            ];
            csvLines.push(row.join(';'));
        });

        // Joindre toutes les lignes
        const csvContent = csvLines.join('\n');

        // √âcrire le fichier simple
        fs.writeFileSync(filepath, csvContent, 'utf8');
        
        console.log(`üìä CSV g√©n√©r√© avec ${tracks.length} lignes (d√©limiteur point-virgule, version simple)`);
    }

    /**
     * G√©n√©rer un timestamp au format YYYYMMDD
     */
    generateTimestamp() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        return `${year}${month}${day}`;
    }

    /**
     * Nettoyer le nom de fichier
     */
    sanitizeFilename(filename) {
        return filename
            .toLowerCase()
            .replace(/[^a-z0-9\s]/g, '') // Supprimer caract√®res sp√©ciaux
            .replace(/\s+/g, '_') // Remplacer espaces par underscore
            .substring(0, 50); // Limiter la longueur
    }
}

module.exports = PlaylistManager; 